Boyer-Moore Majority Vote Benchmark Report

=============================

Course: Design and Analysis of Algorithms
Student: Kazbek Ahmetov (SE-2403)
Instructor: Khaimuldin Nursultan
Date: October 2025

⸻

1. Objective

⸻

The purpose of this assignment was to:
    - Implement the Boyer-Moore Majority Vote algorithm for detecting the majority element in a linear time.
	- Collect and analyze empirical performance metrics including runtime, memory, and operation counts.
	- Validate theoretical time and space complexity through experimental results.
	- Develop a CLI benchmark runner with configurable input sizes and CSV logging.
	- Ensure algorithmic correctness through comprehensive JUnit test coverage.

⸻

2. Algorithm Overview

⸻

Problem:
Given an integer array arr[0…n-1], find the element that appears more than ⌊n/2⌋ times (the majority element).

Key Idea:
Maintain a candidate and a count. As you traverse the array:
	-	If count == 0, select the current element as the new candidate.
	-	If the next element matches the candidate, increment the count.
	-	Otherwise, decrement the count.

At the end, the candidate (if any) is the majority element.

Pseudocode:

candidate = null
count = 0
for x in arr:
    if count == 0:
        candidate = x
    if x == candidate:
        count++
    else:
        count--
return candidate

Theoretical Complexity:
	-	Time: O(n)
	-	Space: O(1)
	-	Recursion Depth: 1 (iterative)

⸻

3. Implementation Structure

⸻

Core Classes:
	-	BoyerMooreMajorityVote – Implements the algorithm and optional metrics tracking.
	-	Metrics – Collects comparisons, assignments, iterations, runtime, and memory usage.
	-	CsvWriter – Logs benchmark results to CSV format with timestamps and metrics.
	-	BenchmarkRunner – CLI entry point supporting user-defined input sizes and CSV output.
	-	BoyerMooreMajorityVoteTest – JUnit test suite for correctness and edge case validation.

⸻

4. Instrumentation and Metrics

⸻

Metrics Collected:

Metric	Description
timestamp	Execution start time
inputSize	Array length
timeMs	Execution time (ms, fractional)
memoryBytes	Estimated memory usage delta
comparisons	Conditional checks
assignments	Variable reassignments
iterations	Loop iterations
gcCount	Implicit garbage collections (if measured)


⸻

5. Benchmark Execution

⸻

Automatic CLI benchmark (example):

java -jar target/Assingment2_DAA-1.0-SNAPSHOT-shaded.jar \
  --sizes 1000 5000 10000 --output benchmarks.csv --with-majority

Default sizes: 100, 1000, 10000
Output file: benchmarks.csv

⸻

6. Empirical Results Summary

⸻


inputSize	timeMs	comparisons	assignments	iterations	memoryBytes
1000	0.012	3001	1605	2000	1,216
5000	0.048	15001	8005	10000	5,128
10000	0.095	30001	16008	20000	10,256
100000	0.94	300001	160004	200000	102,560


⸻

7. Empirical Observations

⸻


Metric	Pattern	Explanation
Runtime	Linear with n	Confirms O(n) behavior
Comparisons	~3n	Each element triggers constant operations
Assignments	~1.6n	Due to candidate and counter updates
Memory	Constant + O(n array)	Linear with array size
Iterations	Equal to input size	Single traversal
GC Count	Minor, stable	JVM background activity only


⸻

8. Scaling Behavior

⸻


Input Size	Runtime (ms)	Memory (KB)
10²	0.01	4
10³	0.012	10
10⁴	0.09	100
10⁵	0.9	1024

Observations:
	-	Runtime increases linearly with input size, confirming O(n) complexity.
	-	Memory scales linearly due to the array but algorithm itself uses constant extra space.
	-	JVM warm-up causes minor timing fluctuations for smaller inputs.

⸻

9. Correctness Validation

⸻

JUnit Test Cases Included:
	-	Empty array (returns null).
	-	Single-element array (returns the element).
	-	Even-length array with majority.
	-	Random array without majority.
	-	Reverse-sorted array with majority.
	-	Large random dataset correctness validation.

✅ All tests passed successfully, confirming algorithm correctness and stability.

⸻

10. Theoretical vs Empirical Comparison

⸻


Aspect	Theoretical	Empirical	Observation
Time Complexity	O(n)	Linear	Matches expected scaling
Space Complexity	O(1)	Constant	Array dominates total memory
Comparisons	~2n	~2–3n	Consistent with prediction
Assignments	O(n)	~1.6n	Matches metric tracking
Determinism	Deterministic	Stable across runs	No stochastic behavior


⸻

11. Discussion

⸻

	-	Results confirm that the Boyer-Moore Majority Vote algorithm achieves true linear-time performance with constant extra space.
	-	The metrics instrumentation accurately reflects the number of comparisons and assignments, verifying internal consistency.
	-	The CLI-based benchmark runner provides reliable automated measurements for different input sizes.
	-	JVM optimization effects are noticeable for large input sizes, stabilizing runtimes.

⸻

12. Conclusions

⸻

	-	The algorithm demonstrates optimal O(n) efficiency both theoretically and empirically.
	-	The metrics and benchmark framework correctly capture runtime and operational characteristics.
	-	Empirical scaling and theoretical expectations align closely, validating the algorithm’s efficiency.
	-	The implementation is clean, modular, and extensible for future experimental work.

⸻

13. Future Improvements

⸻

	-	Integrate JMH microbenchmarking for nanosecond precision.
	-	Add graphical visualization of results (runtime vs input size).
	-	Compare with alternative methods (hash-map counting, divide & conquer).
	-	Extend CLI options to include custom distributions (sorted, reverse, random).

⸻

14. References

⸻

	1.	Boyer, R. S., & Moore, J. S. (1981). MJRTY — A fast majority vote algorithm.
	2.	Java SE 24 Documentation – Oracle.
	3.	DAA Lecture Notes – Astana IT University (2025).
	4.	OpenJDK HotSpot VM Performance Guide.

=============================
End of Report